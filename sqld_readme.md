---

[SQLD 요약정리 2021.pdf](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ab80420-dc7e-4fc5-8f76-006851503a18/1ae32eda-1c18-4503-9b9e-70641e58f711/SQLD_%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5_2021.pdf)

Table ( = Relation = 관계 ) : 데이터를 기록하는 곳  

Field (  = Column = Attribute ) : 고유한 데이터 형식 ( 타입 ) 이 지정됨 

Record ( = Row = Tuple ) : 구체적인 데이터 값이 저장됨 

Database ( = Schema ) : 테이블의 집합 

## 기출 노트

- **데이터 모델링 : 
종류 : 개논물**        개념적 / 논리적 / 물리적 모델링 

**개념적 : 가장 높은 수준의 추상화 모델링** 
논리적 : 재사용성 ++ 

**특징 : 추단명**        추상화 / 단순화 / 명확화 
**고려 사항 : [ 데이터 중복 / 비 유연성 / 비 일관성 ] 발생하지 않게**!
- **데이터 모델 관점 : 데이터 & 프로세스**

---

- **엔터티** : 실체 / 객체  /                **다른 개체와 확연히 구분 > 모델의 독립성 향상**
              **기업에서 관리하고자 하는 데이터 / 집합의 특성**  / **순수 개체 OR 행위 집합**

**특징 : 속성 / 유일 식별자 필수 / 인스턴스, 속성 2개 / 타 엔터티와 관계 1개+ / 고객이 관심사항**

**분류 : 키메행**
**1. 키 엔터티 : 다른 엔터티의 도움 없이 생성 
2. 메인 엔터티 : 업무처리 중심이 되는 엔터티. 부모 엔터티(키 엔터티) 로 부터 파생
3. 행위 엔터티 : 업무처리 동안 발생되는 엔터티. 자주 변경 / 지속적으로 정보 추가됨** 
      ㄴ**데이터양 가장 많음** 

**유무형 따라    : 유형 / [ 개념 / 사건 ]** 엔터티 
발생시점 따라 : 기본 / 중심 / 행위 엔터티

---

- **식별자** : 유일성 만족해야  << 특징 : **최유존** 존재성(NULLX)  / 유일성 / 최소성 

주 & 보조  -  대표성에 따라
**주**     : **유일성 / 최소성 / 대표성 / Not NULL**
**보조 : 대표성 X → 참조 관계 X / 엔터티 내 여러 인스턴스 중 하나 유일하게 구분 가능**  

단일 & 복합  -  속성 수에 따라

본질 & 인조  -  **대체 여부**에 따라
**인조 : 최대한 범용적인 값 사용해 만듦 / 유일한 값 만들기 위해** 
           **하나의 인조 속성을 다른 것으로 대체 불가** 

내부 & 외부 - 생성 여부에 따라 
내부 : 엔터티 내부에서 스스로 생성 , 외부 : 다른 엔터티의 관계로 만들어짐

---

- **속성** : **속기설파**
    ㄴ 사물의 성질 / 특징 / 본질적 성질 의미 
    ㄴ **주식별자에게 함수적으로 종속 /** 업무에서 관리 / 하나의 값만 가지지 않음 
         **특성에 따른 분류 [ 기본 / 설계 / 파생 속성 ]**

---

- **관계 : 
존재 관계 : 엔터티 간의 상태 의미 ( 직원, 부서간의 소속관계 )** 

**식별 관계 : 강한 연결 + 실선 / 반드시 부모에 종속 
부모 엔터티 주식별자 > 자식 엔터티 주식별자**  

**비식별** 관계 : 약한 연결 / 약한 종속 / ERD **점선** / 자식 → 일반 속성
- 키 : 
**후보키 : 최소성 / 유일성 만족** 
슈퍼키 : 최소성X 유일성O 
외래키 : 다른 테이블의 기본키 참조 
기본키 : 자동으로 인덱스 생성 

UNIQUE : **NULL 값 빼고** 중복 거름

- **ERD 작성 절차** : 도배엔 서참필 / 2개중에 하나 택1이면 비포괄

엔터티 도출하고 그림 / 엔 배치 / 엔 관계 설정 / 관계 서술 / 관계 참여도 표현 / 관계 필수 여부 표현

- 왼쪽은 필수  /  오른쪽은 선택

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ab80420-dc7e-4fc5-8f76-006851503a18/5b521836-cb8a-4c2b-9a19-bed08eee124f/image.png)

- **3층 스키마** : DB 독립성 향상하기 위해 사용 
**개념 스키마 : 조직 전체적인 관점으로 통합 표현
내부 스키마 : DB 물리적 저장 구조 의미** 
외부 스키마 : 업무상 관련있는 데이터만 접근(권한설정)한다

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ab80420-dc7e-4fc5-8f76-006851503a18/ba0f7540-220a-4e2c-8aa1-42c2a1945a26/image.png)

- **정규화** : 
데이터 모델 자주 변경되는 경우 진행 > **데이터 중복 제거** 
> 모델의 **독립성** / 유연성 향상
**엔터티의 의미 해석 명확 /** 테이블 수 & 조회시 조인 수 증가 

—> 하지 않아서 발생하는 문제점 ? : **이상 현상**  ( 삽입 / 갱신 / 삭제 ) 

1정규화 : 속성 중복값 제거
**2정규화** : 부분 종속성 제거 / **기본키가 2개 이상**인 경우만 ! 
**3정규화** : **이행함수 종속성 제거** [ **기본키 / 주식별자 제외**한 칼럼간 종속성 있다면 분할 / 제거 ]
 ㄴ 밑의 이미지 참조 
**BCNF : 기본키 제외하고 후보키가 존재 / 후보키가 기본키의 속성중 하나를 함수적으로 종속**
- **반정규화** : 필수 X
**정규화 수행한 후**에 수행 [ 트랜젝션 유형 / 용량 등 분석하고 ] 
데이터 중복 허용 → 성능 향상 → 데이터 독립성 향상 X
**SELECT 문에서 JOIN 제거** → 조회속도+ ->
- 수평분할 기법 : 특정 값에 따라서 테이블 분할
- 데이터 중복 제거 → 데이터 모델의 유연성 향상 [ 정규화 / 3층 스키마 / 이상현상 제거 ]
- JOIN : Single Type : 슈퍼 타입 / 서브 타입을 하나의 테이블로 생성 > 조인 성능 좋고 관리 편함
- 좋은 모델링 요건 : 중복 배제 / 비즈니스 룰 / 완전성

카티션곱 : 2개 테이블 곱한다고 생각 ( FROM으로 2개 테이블 불러 왔을때, 카테시안 곱 발생 ) 
M*N 관계에서 발생 

- **차수 : 결과 릴레이션의 칼럼 수**
- **카디널리티 : 선택된 행들의 개수 / 전체 레코드 수 * 선택도**
                      **하나의 릴레이션에서 튜플의 전체 개수** ( 테이블에서 레코드의 전체 개수 )

- **선택도 : 특정 조건에 의해 선택될 것으로 예상하는 레코드의 비율**
- 도메인 : 하나의 속성이 가질 수 있는 모든 원자 값들의 집합
- REGEXP_LIKE : 정규표현식에서 LIKE문과 유사 / 숫자만을 검색 위해서 ‘[0-9]’
- 정규표현식 [:alnum:] : 알파벳과 숫자로 이루어진 것 찾을 수 있음

---

- 관계형 DB 
1. **집합 연산 종류 : 합 / 차 / 교 / 곱집합** 

2. 관계 연산 : 
종류 : 
**결합 연산 =** JOIN : **공통된 속성으로 새로운 릴레이션 생성**
- EQUI : = 를 사용해 조인하는 것   <<<  **HASH JOIN 사용 가능** ( **선행 테이블 작아야** 유리 ) 
                                                                   ㄴ **CPU 부하 크지만, 랜덤 액세스 X** 
조인 칼럼이 1:1로 맵핑 가능하면 사용 가능 ( 반드시 기본 / 외래키 관계 의해 성립  X )
- NON - EQUI : = 이외를 사용해 조인하는 것
- **NESTED-LOOP : 랜덤 엑세스** 
 선행 테이블에서 조건 만족하는 첫 행 찾음 
→ 선행 테이블의 조인 키 가지고 후행 테이블에 조인 키 존재하는지 찾으러 가서 조인 시도 
→ 후행 테이블의 idx에 선행 테이블의 조인 키가 존재하는지 확인 
→ idx에서 추출한 레코드 식별자를 이용하여 후행 테이블을 엑세스
- Sort Merge : 2개의 테이블을 sort한 후에 merge → 한번의 Full Scan으로 데이터를 검색 → 외래키가 idx에 없을 때에 옵티마이저가 sort merge 방식의 조인으로 동작하게 한다. 
* USE_MERGE Hint 를 사용해서 의도적으로 sort merge join 하게 함 
* sort 한 이후에 merge 실행하는 것 볼 수 있음 
* EQ, NONEQ 다 사용 가능
- **NATURAL** : 두 테이블 간에 **동일한 칼럼 이름을 가진** 것을 모두 출력  
                   **약어 X** / 동일한 칼럼 2개 이상이면 JOIN ~ USING 문 사용
- SELF  : **한 테이블 내에서 두 칼럼이 연관**되어 있어야 / ANY ( 질의결과 모든값 리턴 ) 사용
- **CROSS** : 데이터 개수 ** 2개 리턴  / **<> 로 표기 가능 ( 같지 않다 )**
- **FULL OUTER : 빈값 존재 = LEFT OUTER UNION RIGHT OUTER**

SQL 종류 : 

- **TCL : COMMIT / ROLLBACK**  < Transaction Control Language 
- 데이터 무결성 보장
한번 COMMIT 된 데이터는 ROLLBACK 해도 되돌아갈 수 없음
- **DCL : GRANT / REVOKE**  < Data Control Language
GRANT : 권한을 부여할 수 있는 권한도 부여  >> WITH GRANT OPTION : 취소시 연쇄취소 

GRANT 권한 ON 테이블 TO 사용자 

REVOKE : 권한을 삭제
- **DDL : CREATE / ALTER / DROP** ( VIEW, INDEX ) < Data Definition Language ) 
           **TRUNCATE < 테이블 용량 초기화 / 롤백 X** 

- 데이터 구조 정의 / 변경 

****ALTER - 칼럼 추가 : ADD
- **DML : INSERT / UPDATE / DELETE / SELECT** ( R U D ) 
              
- 데이터 변경 / 삭제 / … 

SELECT : 최종 결과 집합에 부여되는 가상의 일련번호 ( ROWID ) 
DELETE : 테이블 용량 감소 X

cf> TRUNCATE : 구조 날라가지 않고, / 데이터 빠르게 삭제 위해 로그 기록 X 

- **실행 순서 : Parsing > Execution > Fetch**
- ON DELETE CASCADE : 참조한 테이블의 데이터까지 자동 삭제 > 참조 무결성 보장 
ROLLBACK 불가 / 자동 COMMIT
- ALTER :
칼럼 추가 : MODIFY 
테이블명 변경 : RENAME TO 

 ALTER TABLE 이전명 **RENAME TO** 이후명 : **테이블명 ALTER** 
 ALTER TABLE 테이블명 **MODIFY (칼럼 number(2) default 1)** 
  : age **칼럼 추가** - 숫자 2자리, 기본값 1

### FROM에서 ALIAS 사용 → SELECT에서 무조건 사용해야

### INSERT :

- Nologging : 성능 향상 위해 버퍼캐시 기록 생략하는 옵션

### 서브쿼리 :

- **사용 : SELECT / FROM / WHERE**

- 괄호로 SELECT문 감싸 사용 / 비교 연산자 사용 가능
- 메인쿼리 : 스칼라, 인라인뷰 서브쿼리 쓸 수 있음 ( 원래 서브쿼리 칼럼 X )

- **Inline view : FROM 절에 사용하는 한줄 서브쿼리** - **메인쿼리에서도 사용 가능**
- Scala Subquery : 반드시 한행, 한칼럼만 반환
- Multi row Subquery : 

ALL : 메인쿼리, 서브쿼리 결과 동일하면 TRUE 
ANY : 어느 하나라도 만족하면 결과값 반환

- SQL 개선 측면에서의 종류 : ( 쿼리의 변형 X )
1. ACCESS : 제공자의 역할 
2. FILTER : 확인자의 역할
3. EARLY FILTER : 서브쿼리가 먼저 실행되어 데이터 걸러냄 

### VIEW :  **삽입, 수정 시 제약 O**

- 가상의 테이블 / 데이터 관리 간단해짐 /  보안 기능 제공

### 인덱스 :

- 내림차순으로 생성 및 정렬
- 규칙 기반 : 규칙에 따라 적절한 인덱스 존재 → 항상 인덱스 사용하려 함
- 테이블을 참조하지 않는 인덱스 / Table을 탐색하지 않고 Fetch : idx 생성 x 테이블 생성 o

### 트랜잭션 :

- 특징 : 영속성 : 트랜잭션 실행 성공적으로 완료 시 결과를 영구 보장 / COMMIT 완료시 저장 보장 
원자성 / 일관성 / 고립성 / 지속성 

- SAVEPOINT : 트랜잭션 작게 분할하여 관리 / 특정 위치까지만 COMMIT / ROLLBACK가능

## 함수

- COUNT : 칼럼명 - NULL값 제외
                   * - NULL값 포함해

- 숫자형 함수 : 
SIGN : 양수 1 / 음수 -1 / 0은 0 리턴 
ROUND(A,-2) : 10의자리에서 반올림 
TRUNC : ( 숫자 , m ) : m+1 자리를 자른다

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ab80420-dc7e-4fc5-8f76-006851503a18/008b97df-9afc-4c26-b825-1b518fe89981/image.png)

- 날짜형 함수 : 
NEXT_DAY : 지정된 요일의 첫번째 날짜 출력

- CONNECT BY 키워드 : 

부모 계층형 쿼리에서 부모-자식 관계 나타냄 
계층 쿼리 : START WITH … CONNECT BY … WHERE ~
   >> 최상위 → 하위 / PRIOR 붙어있으면 역방향 /  

LEVEL : 가장 상위 레벨 1부터 → 1 > 2 > … 
CONNECT BY ISLEAF : 전개 과정에서 LEAF면 1, 아니면 0

- SUBSTR : 문자열 N개 뽑아내기
- LPAD : 왼쪽에 삽입 (A,2,B) : A에 B 삽입해 LEN 2 만들기
- INSTR(A,B,C,D) : A에서 B를 C부터 시작해서 D번째 있는거의 IDX 줌
- LTRIM : 왼쪽에서 제거

### GROUP BY 확장 → ROLLUP, CUBE ( 병렬 수행 가능 / 사용 쉬움 )

** 그룹 함수 만나면 NULL값은 연산에서 제외됨 
** WINDOW FUNC와 골라서 사용 ( 2중 1 )

- ROLLUP : GROUP BY 칼럼에 대해 **전체합계 열 만들어줌**
- CUBE     : 다차원적인 집계 필요한 경우, 주어진 칼럼에 대해 **결합 가능한 모든 집계** 게산 
                 <   **GROUPING SETS** 이용해서 비슷하게 가능

- 문자열 결합 : CONCAT  &&  ‘||’
- NULL과 모든 연산 : NULL    &    NULL = NULL 은 공집합
NULL값을 비교하려면 IS NULL 사용

- **COALESCE : NULL값이 아닌 첫번째 인자**값 반환
- NVL, ISNULL(A, B) : A NULL → B / 아니면 A 
          < 그룹 함수 만나면 NULL값은 연산에서 제외됨
- NULLIF(A,B) : A=B면 NULL / 아니면 A
- DECODE : A=B이면 C / 아니면 D
- ALL(A, B) : 서브쿼리 값 모두가 조건 만족 → TRUE 반환

- 절차형 SQL 이용해 만들 수 있는 것 → PROCEDURE / TRIGGER / USER DEFINED FUNC

### 집합 연산자 :

- 합집합 - **UNION** : 두개의 테이블을 하나로 합치며 **중복 데이터 제거** / **정렬** 과정 발생 
              UNION ALL : 정렬 X / **여러번 중복 표현** << 성능 더 우수하다 .
- 차집합 - MINUS ( 오라클 ) <> EXCEPT ( MS-SQL )
- 교집합 - INTERSECT

### SELECT문 실행 순서 :

- FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
- → SELECT 문에서 만든 AS WHERE절에서 사용 못함!

### 윈도우 함수 :

- ROWS : 물리적 단위로 행 저장
- RANK : 순위를 구함 ( 행의 순서 관계 X ) 
DENSE RANK : 동일한 순위를 하나의 건수로 - 빈값 없이 1223 이런식으로 감
- PERCENT_RANK : 인수로 지정한 값의 그룹 내의 위치를 백분위로 나타냄
- CUME_DIST : 주어진 그룹에 대한 상대 누적분포도 값 반환 ( 0 ~ 1 값 )

- **ROW_NUMBER : 고유한 순위** 부여
- 파티션문 : 해당 파티션 내에서 순위 계산 가능
- RANGE : 논리적 주소에 의한 행 집합 지정
- BETWEEN ~ AND : 윈도우의 시작과 끝을 지정한다
- UNBOUNDED PRECEDING : 윈도우의 시작 위치가 첫번째 행임을 의미
- FOLLOWING : 윈도우의 마지막 위치가 마지막 행임을 의미
- CURRENT ROW : 윈도우 시작 위치가 현재 행임을 의미
- NTILE : 데이터를 인자 값으로 N등분하는 함수
- **LAG : 앞 N번째 행 값**
- **LEAD : 뒤 N번째 행**

- ROWNUM : SELECT문에서 행 인출될 때에 행에 부여되는 일련번호

### CASE문 :

- ELSE조건 생략하면 NULL 되돌려짐
- IF - THEN - ELSE
- DECODE : A=B이면 C / 아니면 D  
DECODE(A, B, C, D)

- SQL 서버 : NULL값 맨 앞에 저장   /   AUTO COMMIT 기본설정 
ORACLE : 맨 뒤에 저장                  /   X